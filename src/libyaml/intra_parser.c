#include <yaml.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "intravisor.h"

int debug = 0;


/*
 * Convert a yaml boolean string to a boolean value (true|false).
 */
int
get_boolean(const char *string, bool *value)
{
    char *t[] = {"y", "Y", "yes", "Yes", "YES", "true", "True", "TRUE", "on", "On", "ON", NULL};
    char *f[] = {"n", "N", "no", "No", "NO", "false", "False", "FALSE", "off", "Off", "OFF", NULL};
    char **p;

    for (p = t; *p; p++) {
        if (strcmp(string, *p) == 0) {
            *value = true;
            return 0;
        }
    }
    for (p = f; *p; p++) {
        if (strcmp(string, *p) == 0) {
            *value = false;
            return 0;
        }
    }
    return EINVAL;
}


/*
 * Consume yaml events generated by the libyaml parser to
 * import our data into raw c data structures. Error processing
 * is keep to a mimimum since this is just an example.
 */
int consume_event(struct parser_state *s, yaml_event_t *event)
{
    char *value;

    if (debug) {
        printf("state=%d event=%d\n", s->state, event->type);
    }
    switch (s->state) {
    case STATE_START:
        switch (event->type) {
        case YAML_STREAM_START_EVENT:
            s->state = STATE_STREAM;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

     case STATE_STREAM:
        switch (event->type) {
        case YAML_DOCUMENT_START_EVENT:
            s->state = STATE_DOCUMENT;
            break;
        case YAML_STREAM_END_EVENT:
            s->state = STATE_STOP;  /* All done. */
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

     case STATE_DOCUMENT:
        switch (event->type) {
        case YAML_MAPPING_START_EVENT:
            s->state = STATE_SECTION;
            break;
        case YAML_DOCUMENT_END_EVENT:
            s->state = STATE_STREAM;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_SECTION:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            value = (char *)event->data.scalar.value;
            if (strcmp(value, "cVMs") == 0) {
               s->state = STATE_FLIST;
			} else if (strcmp(value, "capfiles") == 0) {
               s->state = STATE_CLIST;
            } else {
               fprintf(stderr, "Unexpected scalar: %s\n", value);
               return FAILURE;
            }
            break;
        case YAML_DOCUMENT_END_EVENT:
            s->state = STATE_STREAM;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_FLIST:
        switch (event->type) {
        case YAML_SEQUENCE_START_EVENT:
            s->state = STATE_FVALUES;
            break;
        case YAML_MAPPING_END_EVENT:
            s->state = STATE_SECTION;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_FVALUES:
        switch (event->type) {
        case YAML_MAPPING_START_EVENT:
            s->state = STATE_FKEY;
            break;
        case YAML_SEQUENCE_END_EVENT:
            s->state = STATE_FLIST;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;


    case STATE_ILIST:
        switch (event->type) {
        case YAML_SEQUENCE_START_EVENT:
            s->state = STATE_IVALUES;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;


    case STATE_IVALUES:
        switch (event->type) {
        case YAML_MAPPING_START_EVENT:
            s->state = STATE_IKEY;
            break;
        case YAML_SEQUENCE_END_EVENT:
            s->state = STATE_FKEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;


    case STATE_FKEY:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            value = (char *)event->data.scalar.value;
            if (strcmp(value, "name") == 0) {
                s->state = STATE_FNAME;
            } else if (strcmp(value, "disk") == 0) {
                s->state = STATE_FDISK;
            } else if (strcmp(value, "runtime") == 0) {
                s->state = STATE_FRUNTIME;
            } else if (strcmp(value, "net") == 0) {
                s->state = STATE_FNET;
            } else if (strcmp(value, "args") == 0) {
                s->state = STATE_FARGS;
            } else if (strcmp(value, "wait") == 0) {
                s->state = STATE_FWAIT;
            } else if (strcmp(value, "callback_in") == 0) {
                s->state = STATE_FCALLBACK_IN;
            } else if (strcmp(value, "callback_out") == 0) {
                s->state = STATE_FCALLBACK_OUT;
            } else if (strcmp(value, "isolation") == 0) {
                s->state = STATE_ILIST;
            } else if (strcmp(value, "fork") == 0) {
                s->state = STATE_FFORK;
            } else {
                fprintf(stderr, "Unexpected key: %s\n", value);
                return FAILURE;
            }
            break;
        case YAML_MAPPING_END_EVENT:
            add_cvm(&s->flist, s->f.name, s->f.disk, s->f.runtime, s->f.net, s->f.args, s->f.isol.base, s->f.isol.size, s->f.isol.begin, s->f.isol.end, s->f.cb_out, s->f.cb_in, s->f.wait, s->f.fork);
            free(s->f.name);
            free(s->f.disk);
            free(s->f.runtime);
            free(s->f.net);
            free(s->f.args);
            free(s->f.cb_in);
            free(s->f.cb_out);
            memset(&s->f, 0, sizeof(s->f));
            s->state = STATE_FVALUES;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_FNAME:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            if (s->f.name) {
                fprintf(stderr, "Warning: duplicate 'name' key.\n");
                free(s->f.name);
            }
            s->f.name = bail_strdup((char *)event->data.scalar.value);
            s->state = STATE_FKEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_FDISK:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            if (s->f.disk) {
                fprintf(stderr, "Warning: duplicate 'disk' key.\n");
                free(s->f.disk);
            }
            s->f.disk = bail_strdup((char *)event->data.scalar.value);
            s->state = STATE_FKEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_FRUNTIME:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            if (s->f.runtime) {
                fprintf(stderr, "Warning: duplicate 'runtime' key.\n");
                free(s->f.runtime);
            }
            s->f.runtime = bail_strdup((char *)event->data.scalar.value);
            s->state = STATE_FKEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_FNET:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            if (s->f.net) {
                fprintf(stderr, "Warning: duplicate 'net' key.\n");
                free(s->f.net);
            }
            s->f.net = bail_strdup((char *)event->data.scalar.value);
            s->state = STATE_FKEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_FWAIT:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            s->f.wait = strtol((char *)event->data.scalar.value, NULL, 10);
            s->state = STATE_FKEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;
    
    case STATE_FFORK:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            s->f.fork = strtol((char *)event->data.scalar.value, NULL, 10);
            s->state = STATE_FKEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_FARGS:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            if (s->f.args) {
                fprintf(stderr, "Warning: duplicate 'args' key.\n");
                free(s->f.args);
            }
            s->f.args = bail_strdup((char *)event->data.scalar.value);
            s->state = STATE_FKEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;


    case STATE_FCALLBACK_IN:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            if (s->f.cb_in) {
                fprintf(stderr, "Warning: duplicate 'callback_in' key.\n");
                free(s->f.cb_in);
            }
            s->f.cb_in = bail_strdup((char *)event->data.scalar.value);
            s->state = STATE_FKEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_FCALLBACK_OUT:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            if (s->f.cb_out) {
                fprintf(stderr, "Warning: duplicate 'callback_out' key.\n");
                free(s->f.cb_out);
            }
            s->f.cb_out = bail_strdup((char *)event->data.scalar.value);
            s->state = STATE_FKEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

////////
    case STATE_IKEY:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            value = (char *)event->data.scalar.value;
            if (strcmp(value, "base") == 0) {
                s->state = STATE_IBASE;
            } else if (strcmp(value, "size") == 0) {
                s->state = STATE_ISIZE;
            } else if (strcmp(value, "begin") == 0) {
                s->state = STATE_IBEGIN;
            } else if (strcmp(value, "end") == 0) {
                s->state = STATE_IEND;
            } else {
                fprintf(stderr, "Unexpected key: %s\n", value);
                return FAILURE;
            }
            break;
        case YAML_MAPPING_END_EVENT:
            s->state = STATE_IVALUES;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_IBASE:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            s->f.isol.base = strtol((char *)event->data.scalar.value, NULL, 16);
            s->state = STATE_IKEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_ISIZE:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            s->f.isol.size = strtol((char *)event->data.scalar.value, NULL, 16);
            s->state = STATE_IKEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_IBEGIN:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            s->f.isol.begin = strtol((char *)event->data.scalar.value, NULL, 16);
            s->state = STATE_IKEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_IEND:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            s->f.isol.end = strtol((char *)event->data.scalar.value, NULL, 16);
            s->state = STATE_IKEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

//////////////////////////
    case STATE_CLIST:
        switch (event->type) {
        case YAML_SEQUENCE_START_EVENT:
            s->state = STATE_CVALUES;
            break;
        case YAML_MAPPING_END_EVENT:
            s->state = STATE_SECTION;
            break;
        case YAML_SCALAR_EVENT:
			printf("something is wrong %s\n", (char *)event->data.scalar.value);while(1);
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_CVALUES:
        switch (event->type) {
        case YAML_MAPPING_START_EVENT:
            s->state = STATE_CKEY;
            break;
        case YAML_SEQUENCE_END_EVENT:
            s->state = STATE_CLIST;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_CKEY:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            value = (char *)event->data.scalar.value;
            if (strcmp(value, "name") == 0) {
                s->state = STATE_CNAME;
            } else if (strcmp(value, "data") == 0) {
                s->state = STATE_CDATA;
            } else if (strcmp(value, "size") == 0) {
                s->state = STATE_CSIZE;
            } else if (strcmp(value, "addr") == 0) {
                s->state = STATE_CADDR;
            } else {
                fprintf(stderr, "Unexpected key: %s\n", value);
                return FAILURE;
            }
            break;
        case YAML_MAPPING_END_EVENT:
            add_capfile(&s->clist, s->c.name, s->c.data, s->c.size, s->c.addr);
            free(s->c.name);
            free(s->c.data);
            memset(&s->c, 0, sizeof(s->c));
            s->state = STATE_CVALUES;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_CNAME:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            if (s->c.name) {
                fprintf(stderr, "Warning: duplicate 'name' key.\n");
                free(s->c.name);
            }
            s->c.name = bail_strdup((char *)event->data.scalar.value);
            s->state = STATE_CKEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_CDATA:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            if (s->c.data) {
                fprintf(stderr, "Warning: duplicate 'data' key.\n");
                free(s->c.data);
            }
            s->c.data = bail_strdup((char *)event->data.scalar.value);
            s->state = STATE_CKEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;


    case STATE_CSIZE:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            s->c.size = strtol((char *)event->data.scalar.value, NULL, 16);
            s->state = STATE_CKEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_CADDR:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            s->c.addr = strtol((char *)event->data.scalar.value, NULL, 16);
            s->state = STATE_CKEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;


//////////////////////////

    case STATE_STOP:
        break;
    }
    return SUCCESS;
}

struct parser_state state;

struct parser_state *run_yaml_scenario(char *yaml_cfg)
{
    int code;
    enum status status;
    yaml_parser_t parser;
    yaml_event_t event;

    memset(&state, 0, sizeof(state));
    state.state = STATE_START;
    yaml_parser_initialize(&parser);

	FILE *in = fopen(yaml_cfg, "r");

	if(in == 0) {
		printf("cannot open %s, die\n", yaml_cfg);
	}

    yaml_parser_set_input_file(&parser, in);
    do {
        status = yaml_parser_parse(&parser, &event);
        if (status == FAILURE) {
            fprintf(stderr, "yaml_parser_parse error\n");
            code = EXIT_FAILURE;
            goto done;
        }
        status = consume_event(&state, &event);
        if (status == FAILURE) {
            fprintf(stderr, "consume_event error\n");
            code = EXIT_FAILURE;
            goto done;
        }
        yaml_event_delete(&event);
    } while (state.state != STATE_STOP);

	return &state;

done:
	fclose(in);
    free(state.f.name);
    free(state.f.disk);
    free(state.f.runtime);
    free(state.f.net);
    free(state.f.args);
    destroy_cvms(&state.flist);
    yaml_parser_delete(&parser);

    return 0;
}